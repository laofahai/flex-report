# LinchKit 技术决策记录 (ADR - Architecture Decision Records)

## 📋 文档说明

本文档记录 LinchKit 项目中的重要技术决策，包括决策背景、考虑的选项、最终决策和理由。每个决策都基于当前的项目状态和验证结果。

**最后更新**: 2025-06-21
**基于状态**: Starter 应用基础功能完全实现

---

## ADR-001: 前端技术栈选择

**状态**: ✅ 已决策并验证
**决策日期**: 2025-06-20
**验证状态**: 通过 Starter 应用实现验证

### 背景

需要为 LinchKit 选择稳定、高效、类型安全的前端技术栈，支持现代化的开发体验和良好的用户体验。

### 考虑的选项

1. **Next.js 14 + React 18** (稳定方案)
2. **Next.js 15 + React 19** (最新方案)
3. **Vite + React 18** (轻量方案)

### 决策

选择 **Next.js 15 + React 19**

### 理由

- ✅ **已验证可行**: Starter 应用成功运行，无兼容性问题
- ✅ **类型安全**: 与 TypeScript 和 tRPC 完美集成
- ✅ **开发体验**: 热重载、错误提示、调试工具优秀
- ✅ **生态系统**: 丰富的组件库和工具支持
- ✅ **性能**: App Router 和 Server Components 提供优秀性能

### 后果

- **正面**: 获得最新特性和性能优化
- **负面**: 可能遇到新版本的未知问题
- **缓解**: 准备降级方案，密切关注社区反馈

---

## ADR-002: UI 组件库选择

**状态**: ✅ 已决策，架构标准化进行中
**决策日期**: 2025-06-21
**验证状态**: Tailwind CSS 已验证，shadcn/ui 架构标准化进行中

### 背景

需要选择合适的 UI 组件库，平衡开发效率、定制性、维护成本和用户体验。基于 Starter 应用的成功实现，需要进一步标准化 UI 组件架构。

### 考虑的选项

1. **Tailwind CSS + 自定义组件** (当前方案)
2. **shadcn/ui + Tailwind CSS** (推荐方案)
3. **Ant Design** (企业级方案)
4. **Material-UI** (Google 设计方案)

### 决策

选择 **shadcn/ui + Tailwind CSS**

### 理由

- ✅ **已验证基础**: Tailwind CSS 在 Starter 应用中表现优秀
- ✅ **高度定制**: shadcn/ui 提供可复制的组件，完全可定制
- ✅ **类型安全**: 完全支持 TypeScript
- ✅ **现代设计**: 符合当前设计趋势
- ✅ **无依赖锁定**: 组件可以完全控制和修改
- ✅ **社区活跃**: 快速发展的生态系统
- ✅ **主题系统**: 支持深色/浅色模式和自定义主题

### 架构标准化决策

基于这个选择，制定了完整的 UI 组件架构标准：

1. **组件分层**: atoms → molecules → organisms → templates
2. **主题系统**: ThemeProvider + CSS 变量 + 预设主题
3. **包间集成**: @linch-kit/ui (统一组件库，包含基础组件、CRUD 组件、UI Blocks)
4. **文档标准**: Storybook + TypeScript + 可访问性

### 后果

- **正面**: 高度灵活性、一致的设计语言、优秀的开发体验
- **负面**: 需要建立完整的组件库基础设施
- **缓解**: 建立详细的最佳实践文档和开发指南

---

## ADR-003: 状态管理策略

**状态**: ✅ 已决策并验证
**决策日期**: 2025-06-20
**验证状态**: tRPC 已验证，Zustand 待集成

### 背景

需要确定前端状态管理策略，处理服务端状态、客户端状态和用户界面状态。

### 考虑的选项

1. **tRPC + React Query** (服务端状态)
2. **Redux Toolkit** (全局状态)
3. **Zustand** (轻量级状态)
4. **Jotai** (原子化状态)

### 决策

选择 **tRPC + Zustand 混合方案**

### 理由

- ✅ **tRPC 已验证**: 服务端状态管理优秀，类型安全
- ✅ **职责分离**: tRPC 处理服务端状态，Zustand 处理复杂客户端状态
- ✅ **简单易用**: Zustand 学习成本低，API 简洁
- ✅ **性能优秀**: 两者都有良好的性能表现
- ✅ **TypeScript 支持**: 完全的类型安全

### 后果

- **正面**: 清晰的状态管理边界和优秀的开发体验
- **负面**: 需要学习两套状态管理方案
- **缓解**: 建立状态管理最佳实践指南

---

## ADR-004: 数据库和 ORM 选择

**状态**: ✅ 已决策，部分验证
**决策日期**: 2025-06-20
**验证状态**: Prisma 配置完成，PostgreSQL 待集成

### 背景

需要选择数据库和 ORM 方案，支持类型安全、迁移管理和复杂查询。

### 考虑的选项

1. **Prisma + PostgreSQL** (推荐方案)
2. **Drizzle + PostgreSQL** (轻量方案)
3. **TypeORM + PostgreSQL** (传统方案)

### 决策

选择 **Prisma + PostgreSQL**

### 理由

- ✅ **类型安全**: 自动生成 TypeScript 类型
- ✅ **开发体验**: 优秀的 IDE 支持和调试工具
- ✅ **迁移管理**: 强大的数据库迁移功能
- ✅ **生态系统**: 与 Next.js 和 tRPC 完美集成
- ✅ **性能**: 查询优化和连接池管理
- ✅ **模块化支持**: 支持多 schema 和模块化设计

### 后果

- **正面**: 优秀的开发体验和类型安全
- **负面**: 学习成本和依赖锁定
- **缓解**: 建立数据库设计最佳实践

---

## ADR-005: API 层架构选择

**状态**: ✅ 已决策并验证
**决策日期**: 2025-06-20
**验证状态**: 完全验证，运行稳定

### 背景

需要选择 API 层架构，确保类型安全、开发效率和运行时性能。

### 考虑的选项

1. **tRPC** (类型安全 RPC)
2. **GraphQL + Codegen** (查询语言)
3. **REST API + OpenAPI** (传统方案)

### 决策

选择 **tRPC**

### 理由

- ✅ **完全验证**: Starter 应用中表现优秀
- ✅ **端到端类型安全**: 从数据库到前端的完整类型安全
- ✅ **开发效率**: 自动生成客户端，无需手写 API 调用
- ✅ **实时更新**: 内置 subscription 支持
- ✅ **错误处理**: 统一的错误处理机制
- ✅ **中间件支持**: 认证、权限、日志等中间件

### 后果

- **正面**: 极高的开发效率和类型安全
- **负面**: 与非 TypeScript 客户端集成困难
- **缓解**: 为需要的场景提供 REST API 适配器

---

## ADR-006: 架构数据存储策略

**状态**: ✅ 已决策并实施
**决策日期**: 2025-06-21
**影响**: 架构一致性和扩展性

### 背景

发现配置与实现不一致：配置指定使用 `simplified` 实体套件（JSON 优先架构），但实际实现使用关联表方式。

### 问题描述

- **配置**: `linch.config.js` 中 `entityKit: 'simplified'` 指定使用 JSON 字段存储角色
- **实现**: 当前 Prisma schema 包含 `UserRole` 关联表
- **影响**: 可能导致功能冲突和维护困难

### 考虑的选项

#### 选项A: 统一使用 JSON 字段

**优点**:

- 符合当前配置
- 简化数据库结构
- 减少查询复杂度
- 更好的性能（单表查询）

**缺点**:

- 查询灵活性降低
- 数据一致性检查困难
- 复杂权限逻辑实现困难

#### 选项B: 统一使用关联表

**优点**:

- 保持当前实现
- 更好的数据一致性
- 支持复杂权限逻辑
- 更好的查询灵活性

**缺点**:

- 需要修改配置
- 增加查询复杂度
- 可能影响性能

### 决策

选择 **选项B: 统一使用关联表**

### 理由

- ✅ **当前实现完整**: 关联表方案已经完全实现并验证可行
- ✅ **权限系统需求**: 支持复杂的角色继承、权限组合、多租户
- ✅ **查询灵活性**: 支持复杂的权限查询和报表生成
- ✅ **数据一致性**: 关系型数据库的外键约束保证数据完整性
- ✅ **扩展性**: 便于未来添加角色审计、权限历史等功能
- ✅ **维护成本**: 避免维护两套不同的架构

### 实施结果

1. ✅ 修改 `linch.config.js` 中的 `entityKit` 为 `multi-tenant`
2. ✅ 保持现有的 Prisma schema 和 tRPC 实现
3. ✅ 验证所有功能正常工作
4. ✅ 更新架构决策记录

### 后果

- **正面**: 架构一致性得到保证，为后续开发奠定稳定基础
- **负面**: 放弃了 JSON 字段的简化优势
- **缓解**: 建立关联表使用的最佳实践指南

---

## ADR-007: UI 组件架构标准化

**状态**: ✅ 已决策，实施中
**决策日期**: 2025-06-21
**依赖**: ADR-002 UI 组件库选择

### 背景

基于 shadcn/ui + Tailwind CSS 的选择，需要建立完整的 UI 组件架构标准，确保组件的一致性、可维护性和可扩展性。

### 架构设计原则

1. **分层组件架构**:

   - **atoms**: 原子组件 (Button, Input, Icon)
   - **molecules**: 分子组件 (SearchBox, FormField)
   - **organisms**: 有机体组件 (Header, Sidebar, DataTable)
   - **templates**: 模板组件 (PageLayout, FormLayout)

2. **包间职责分离**:

   - **@linch-kit/ui**: 统一 UI 组件库，包含基础组件、CRUD 组件、UI Blocks
   - **Starter 应用**: 认证相关组件直接实现，便于用户自定义

3. **主题系统架构**:
   - **ThemeProvider**: 全局主题配置和状态管理
   - **CSS 变量系统**: 基于 HSL 的颜色令牌
   - **预设主题**: 默认、深色、浅色、系统自动检测

### 决策

采用 **分层模块化 + 主题系统 + 文档驱动** 的架构

### 理由

- ✅ **可维护性**: 清晰的组件分层和职责分离
- ✅ **可扩展性**: 支持业务组件的独立开发和发布
- ✅ **一致性**: 统一的主题系统和设计语言
- ✅ **开发体验**: Storybook 文档和 TypeScript 支持
- ✅ **可访问性**: 内置 ARIA 支持和键盘导航

### 实施计划

1. **第一阶段**: shadcn/ui 组件封装和主题系统
2. **第二阶段**: 通用 CRUD 组件开发
3. **第三阶段**: 业务组件包的标准化

### 后果

- **正面**: 建立了可持续发展的组件生态系统
- **负面**: 初期需要投入较多时间建设基础设施
- **缓解**: 分阶段实施，优先完成核心组件

---

## ADR-008: Auth UI 包策略调整

**状态**: ✅ 已决策
**决策日期**: 2025-06-21
**依赖**: ADR-007 UI 组件架构标准化

### 背景

原计划开发独立的认证 UI 包，但在实际开发过程中发现认证 UI 组件具有高度的业务定制性，不同项目对认证流程和界面有不同需求。

### 问题分析

1. **高定制需求**: 认证界面通常需要根据品牌和业务需求深度定制
2. **业务逻辑耦合**: 认证流程与具体业务逻辑紧密相关
3. **维护复杂性**: 独立包需要考虑各种使用场景，增加维护复杂度

### 考虑的选项

1. **独立认证 UI 包** (原计划)
2. **Starter 应用中直接实现** (新方案)
3. **混合方案**: 基础组件在 @linch-kit/ui，具体实现在应用中

### 决策

选择 **Starter 应用中直接实现认证 UI 组件**

### 理由

- ✅ **便于定制**: 用户可以根据需求自由修改认证界面
- ✅ **降低复杂度**: 减少包间依赖和维护成本
- ✅ **最佳实践示例**: Starter 应用提供完整的认证实现示例
- ✅ **shadcn/ui blocks**: 可以直接使用 shadcn/ui 的 Login blocks
- ✅ **灵活性**: 不同项目可以选择不同的认证方案

### 实施策略

1. **@linch-kit/ui 增强**: 提供认证相关的基础组件和 blocks
2. **Starter 应用示例**: 实现完整的认证流程作为最佳实践
3. **文档指导**: 提供认证 UI 组件的开发指南

### 后果

- **正面**: 提高了灵活性，降低了维护成本
- **负面**: 用户需要自己实现认证 UI 组件
- **缓解**: 提供完整的示例和开发指南

---

## ADR-010: CRUD UI 组件架构决策

**状态**: ✅ 已决策
**决策日期**: 2025-06-21
**依赖**: ADR-007 UI 组件架构标准化

### 背景

需要决定 CRUD UI 组件的归属和架构设计，平衡组件复用性、维护成本和用户使用便利性。

### 问题分析

1. **组件复用**: CRUD 组件与基础 UI 组件有高度依赖关系
2. **包管理复杂度**: 独立包会增加依赖管理和版本同步复杂度
3. **用户体验**: LinchKit 追求简化用户使用体验的目标

### 考虑的选项

#### 选项A: 创建独立的 CRUD UI 包

**优点**:

- 清晰的职责分离
- 独立发布和版本管理
- 可选择性安装

**缺点**:

- 增加包管理复杂度
- 可能导致依赖冲突
- 用户需要管理多个包的版本同步

#### 选项B: 集成到现有的 @linch-kit/ui 包中

**优点**:

- 简化依赖管理
- 更好的组件复用和一致性
- 用户只需安装一个 UI 包
- 减少版本同步问题

**缺点**:

- 包体积增大
- 职责边界相对模糊

### 决策

选择 **选项B: 集成到 @linch-kit/ui 包中**

### 理由

- ✅ **简化用户体验**: 用户只需安装一个 @linch-kit/ui 包即可获得完整的 UI 组件
- ✅ **组件复用优化**: CRUD 组件可以直接复用基础组件，避免重复实现
- ✅ **依赖管理简化**: 减少包间依赖和版本同步问题
- ✅ **主题一致性**: 确保所有组件使用相同的主题系统
- ✅ **开发效率**: 统一的构建、测试和发布流程

### 实施策略

1. **子模块组织**: 通过 `@linch-kit/ui/crud` 子模块导出 CRUD 组件
2. **分层架构**: 保持 atoms → molecules → organisms → templates 的分层结构
3. **按需导入**: 支持按需导入，避免不必要的包体积增加
4. **文档分离**: 在 Storybook 中分别组织基础组件和 CRUD 组件文档

### 架构设计

```typescript
// 包结构
@linch-kit/ui
├── components/
│   ├── ui/           # 基础 shadcn/ui 组件
│   ├── crud/         # CRUD 专用组件
│   │   ├── data-table.tsx
│   │   ├── form-builder.tsx
│   │   ├── searchable-select.tsx
│   │   └── index.ts
│   └── blocks/       # shadcn/ui blocks 封装
└── exports:
    ├── "@linch-kit/ui"      # 基础组件
    ├── "@linch-kit/ui/crud" # CRUD 组件
    └── "@linch-kit/ui/blocks" # Blocks 组件
```

### 后果

- **正面**: 简化了用户使用体验，提高了组件一致性和开发效率
- **负面**: 包体积相对增大，需要良好的代码组织
- **缓解**: 通过 tree-shaking 和按需导入优化包体积

---

## ADR-009: 模块化架构设计原则

**状态**: 📋 规划中
**规划日期**: 2025-06-21
**依赖**: ADR-006 的决策结果

### 背景

需要设计可扩展、可维护的模块化架构，支持插件系统和业务模块的统一管理。

### 设计原则

1. **分层模块化**:

   - 系统级模块（粗粒度）
   - 业务级模块（中粒度）
   - 功能级插件（细粒度）

2. **统一抽象**:

   - 统一的模块描述格式
   - 统一的生命周期管理
   - 统一的依赖关系管理

3. **跨模块协作**:
   - 事件总线通信
   - 分布式事务处理
   - 数据隔离和权限控制

### 待决策问题

1. **系统设置模块定位**: packages/core vs 独立模块
2. **模块间通信机制**: 事件总线 vs 直接调用
3. **配置管理策略**: 集中式 vs 分布式

---

## 📋 决策跟踪

### 已完成决策 ✅

- [x] ADR-001: 前端技术栈选择 (Next.js 15 + React 19)
- [x] ADR-002: UI 组件库选择 (shadcn/ui + Tailwind CSS)
- [x] ADR-003: 状态管理策略 (tRPC + Zustand)
- [x] ADR-004: 数据库和 ORM 选择 (Prisma + PostgreSQL)
- [x] ADR-005: API 层架构选择 (tRPC)
- [x] ADR-006: 架构数据存储策略 (关联表架构)
- [x] ADR-007: UI 组件架构标准化 (分层模块化 + 主题系统)
- [x] ADR-008: Auth UI 包策略调整 (Starter 应用中直接实现)
- [x] ADR-010: CRUD UI 组件架构决策 (集成到 @linch-kit/ui 包)

### 待决策项目 ⚠️

- [ ] ADR-009: 模块化架构设计原则

### 实施中项目 🔄

- [ ] ADR-007: UI 组件架构标准化 (shadcn/ui 集成进行中)
- [ ] ADR-008: Auth UI 策略调整 (Starter 应用认证组件优化)
- [ ] ADR-010: CRUD UI 组件开发 (DataTable, FormBuilder, SearchableSelect)

### 未来决策 📋

- [ ] 测试策略选择
- [ ] 部署和 CI/CD 策略
- [ ] 监控和日志策略
- [ ] 安全策略和最佳实践

---

**维护说明**: 每个重要的技术决策都应该记录在此文档中，包括背景、选项、决策和后果。这有助于团队理解决策历史和进行未来的架构演进。
