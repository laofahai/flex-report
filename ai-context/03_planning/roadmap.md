# LinchKit 开发路线图

## 🎯 重大架构调整：平台化转型计划

**状态**: 基于与 Gemini 的深度协商，确定架构重构方向  
**核心目标**: 从"功能固定的产品"转变为"可扩展的平台"  
**关键调整**: Starter 轻量化 + Console 平台化 + 混合开发模式

## 🚀 架构重构六阶段实施计划

### Phase 1: 包完整性验证与增强 (1-2周) ⏳ 当前阶段

#### 🔄 进行中的任务

**1. 包依赖关系梳理**
- **目标**: 确保架构约束 core → schema → auth → crud → trpc → ui
- **任务**: 
  - 审查当前包的依赖关系
  - 移除不必要的循环依赖
  - 验证包的独立性
- **状态**: 🔄 分析中

**2. API 完整性检查**
- **目标**: 确保每个包都可以独立使用
- **任务**:
  - 审核各包的 API 完整性
  - 补充缺失的功能和接口
  - 编写独立使用文档和示例
- **状态**: 🔄 评估中

**3. 独立使用验证**
- **目标**: 验证包在现有项目中的集成能力
- **任务**:
  - 创建"不使用 Console"的纯包集成示例
  - 编写每个包的独立 README
  - 单元测试覆盖率达标（core > 90%, 其他 > 80%）
- **状态**: 📋 待开始

### Phase 2: Console 平台化重构 (2-3周)

#### 📋 核心任务

**1. Console 架构重构**
- 创建 `LinchKitConsole` 主组件
- 实现配置驱动的功能启用机制
- 建立统一的 Context 和 Provider 系统
- 实现动态路由注册机制

**2. 移除业务逻辑实现**
- 将所有业务逻辑移到对应的 packages
- Console 只做集成，不做实现
- 建立清晰的扩展 API

**3. 共享服务设计**
- 实现核心 Hooks：`useLinchKit()`, `useCurrentUser()`
- 建立统一的主题、权限、导航系统
- 创建组件覆盖和扩展机制

### Phase 3: Starter 精简与配置系统 (1周)

#### 📋 核心任务

**1. 依赖精简**
- 移除所有 UI 组件依赖
- 移除直接业务逻辑包
- 保留最小运行时依赖：core, console, next, react

**2. 配置文件系统**
- 设计和实现 `LinchKitConfig` 接口
- 实现配置文件解析和验证
- 支持环境变量注入和默认值

**3. 多模式支持**
- 实现 `console` 模式（纯 Console）
- 实现 `hybrid` 模式（Console + 自定义）
- 实现 `packages-only` 模式（纯包集成）

### Phase 4: 混合开发模式实现 (2周)

#### 📋 核心任务

**1. 动态路由系统**
- 实现自定义路由注册机制
- 支持路由级权限控制
- 实现代码分割和懒加载

**2. 导航集成**
- 自定义导航项集成到 Console 导航
- 支持图标、权限、分组等配置
- 实现导航的动态显示/隐藏

**3. 开发者体验优化**
- 创建 CLI 工具支持路由和导航的快速添加
- 提供官方的 hybrid 模式模板
- 编写详细的混合开发指南

### Phase 5: 插件系统与生态建设 (2-3周)

#### 📋 核心任务

**1. 插件系统核心**
- 在 @linch-kit/core 中实现插件管理器
- 定义 `LinchKitPlugin` 接口规范
- 实现插件生命周期管理

**2. 官方插件开发**
- @linch-kit/plugin-user-management
- @linch-kit/plugin-tenant-management
- @linch-kit/plugin-analytics
- @linch-kit/plugin-monitoring

**3. 插件开发工具**
- 创建插件开发模板
- 编写插件开发指南
- 实现插件热重载开发模式

### Phase 6: 文档、测试与优化 (1-2周)

#### 📋 核心任务

**1. 文档体系完善**
- 更新架构设计文档
- 编写三种使用模式的完整指南
- 创建最佳实践和迁移指南
- 建立插件开发者文档

**2. 测试覆盖率提升**
- 核心包单元测试覆盖率 > 90%
- Console 集成测试覆盖率 > 80%
- E2E 测试覆盖主要使用场景

**3. 性能优化**
- 代码分割优化
- 构建时间优化（< 10秒）
- 运行时性能监控

## 📅 时间线和里程碑

### 近期目标 (Phase 1: 1-2周)
- [ ] 包依赖关系审查和优化
- [ ] 各包 API 完整性验证
- [ ] 独立使用文档编写
- [ ] 单元测试覆盖率达标

### 中期目标 (Phase 2-4: 5-6周)
- [ ] Console 平台化重构完成
- [ ] Starter 精简为最小启动器
- [ ] 混合开发模式实现
- [ ] 配置驱动的功能控制

### 长期目标 (Phase 5-6: 3-5周)
- [ ] 完整插件系统生态
- [ ] 官方插件开发完成
- [ ] 文档和测试体系完善
- [ ] 性能优化和生产就绪

## 🔄 后续阶段计划: Phase 10 企业级功能扩展

### Phase B: 基础设施完善 (2-3周)
**目标**: 开发生态和文档体系完善

#### Phase B1: 官网+文档平台 (1周)
- 🔄 **应用创建**: `apps/website` Next.js 15 + Nextra
- 📝 **文档迁移**: 现有文档转换为 MDX 格式  
- 🌐 **域名部署**: `kit.linch.tech` 自动部署配置
- 🔗 **内容同步**: API 文档自动生成机制
- 🎨 **UI 复用**: 集成 @linch-kit/ui 组件库

#### Phase B2: 开发流程增强 (3-5天)
- 📋 **流程规范**: 更新开发约束文档同步要求
- 🔄 **Git Hooks**: 文档完整性检查和验证
- 🤖 **CI/CD**: 文档构建和部署自动化
- 📊 **质量监控**: 测试覆盖率、构建性能监控

#### Phase B3: 发布体系优化 (3-5天)  
- 🏷️ **版本管理**: changesets + 语义化版本完善
- ✅ **发布验证**: 文档、测试、构建全通过才能发布
- 🔄 **自动同步**: 发布后官网特性和版本信息自动更新
- 📈 **兼容性**: API 破坏性变更检查和预警

#### Phase B4: 监控和运维 (2-3天)
- 📊 **性能监控**: Web Vitals + 构建时间监控  
- 🐛 **错误追踪**: Sentry 集成和错误报告
- 📈 **使用分析**: 文档访问统计和用户行为
- 🔍 **日志聚合**: 基于 @linch-kit/core 的日志系统

### Phase 10.3: 增强 modules/console (2-3周)
**目标**: 多租户管理和权限界面完善
- **基础**: 利用现有多租户架构
- **扩展功能**:
  - 完整的租户CRUD和生命周期管理
  - 权限管理界面(角色/权限矩阵)
  - 租户配额和计费管理基础
  - 数据隔离安全加固
  - 系统监控和审计界面

### Phase 10.4: 增强 @linch-kit/core (1-2周)
**目标**: 实时通知和事件系统基础
- **基础**: 利用现有audit系统和插件架构
- **扩展功能**:
  - 事件系统基础设施
  - WebSocket实时通信支持
  - 完善审计日志框架（保留在core中）
  - 通知管理核心功能

### Phase 10.5: 整合优化 (1周)
**目标**: 功能集成和性能优化
- 跨包功能集成测试
- 性能监控和优化
- 文档和示例完善

## 🎯 成功指标

### 用户体验指标
- **工作效率**: 多页面同时操作，快速切换
- **功能发现**: 全局搜索快速定位任何功能
- **视觉一致**: 企业级品牌定制

### 技术质量指标
- **性能**: 标签页切换<200ms，搜索响应<500ms
- **稳定性**: 无构建错误，完整测试覆盖
- **兼容性**: 主流浏览器支持，响应式设计

### 架构清晰度
- **职责分离**: starter和console边界明确
- **接口标准**: SearchProvider接口可被其他模块复用
- **扩展性**: 新模块轻松集成多标签页和搜索

## 💡 关键决策记录

1. **架构转型**: 经与 Gemini 协商，确定从"产品"转向"平台"的战略方向
2. **Console 重新定位**: 从"功能库"升级为"平台基础设施"，支持扩展
3. **混合开发模式**: 在 Console 基础上扩展自定义功能，而非完全替代
4. **包独立性**: 确保每个包功能完整，可独立使用和集成
5. **渐进式开发**: 支持从开箱即用到完全自定义的平滑升级路径
6. **开发者体验**: 优先考虑 DX，提供强大的 CLI 工具和文档

## ⚠️ 风险和挑战

### 技术风险
- **依赖冲突风险**: 自定义组件可能引入不兼容依赖
- **性能风险**: 动态路由和代码分割的性能影响
- **兼容性风险**: 架构重构可能破坏现有代码

### 解决方案
- **依赖管理**: 使用 peer dependencies 和版本锁定
- **性能优化**: 代码分割、懒加载、性能监控
- **平滑迁移**: 提供向后兼容和自动化迁移工具

### 业务风险
- **用户学习成本**: 新架构的学习和适应成本
- **生态建设风险**: 插件生态需要时间建立

### 缓解措施
- **详细文档**: 完整的使用指南和最佳实践
- **官方先行**: 官方插件建立标准和示例
- **社区支持**: 建立开发者社区和问题反馈渠道