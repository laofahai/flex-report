# LinchKit AI 辅助代码生成策略

## 1. 愿景与目标

将 AI 能力深度融入 LinchKit 的代码生成流程，从传统的模板脚手架升级为智能、上下文感知的代码生成器。旨在大幅提升开发效率，确保生成的代码严格遵循 LinchKit 的架构模式、编码规范和最佳实践。

**核心目标：**
*   **极致开发效率**：根据 Schema 定义或自然语言描述，自动生成高质量、可直接使用的代码。
*   **架构一致性**：确保生成的代码与 LinchKit 的分层架构、模块化设计和类型安全原则完全一致。
*   **AI-First**：使 AI 成为代码生成的“大脑”，理解开发者意图并生成符合上下文的代码。
*   **Schema 驱动**：利用 LinchKit 的 Schema 作为单一事实来源，驱动代码生成，确保端到端的一致性。

## 2. 核心能力与集成

### 2.1. 智能脚手架

*   **扩展 `create-linch-kit`**：将现有的脚手架工具升级，使其能够调用 AI 模型。
*   **交互式生成**：通过 CLI 交互式问答，收集用户需求，并将其转化为 AI 可理解的输入。
*   **生成内容**：
    *   **CRUD 模块**：根据 Schema 定义，自动生成完整的 CRUD 操作（服务层、tRPC 路由、UI 表单/表格）。
    *   **新功能模块**：根据用户描述，生成新的功能模块骨架，包括路由、组件、API 接口等。
    *   **测试用例**：为生成的代码自动生成基础的单元测试和集成测试。
    *   **文档**：自动生成符合 LinchKit 文档规范的 `README.md` 和 `ai-context/library-api/*.md`。

### 2.2. 上下文感知生成

*   **利用知识图谱 (Graph RAG)**：
    *   AI 在生成代码时，可以查询 LinchKit 的知识图谱，获取现有代码的上下文信息、依赖关系、使用模式和架构约束。
    *   例如，当生成一个新功能时，AI 可以识别项目中已有的相关 Schema、服务或 UI 组件，并建议复用它们。
*   **遵循编码规范**：AI 生成的代码将严格遵循 LinchKit 的 ESLint、Prettier 规则和 TypeScript 严格模式。
*   **最佳实践注入**：AI 将根据 LinchKit 的架构原则和最佳实践（如错误处理、日志记录、权限检查）生成代码。

### 2.3. AI 模型选择与集成

*   **模型选择**：优先使用能够理解代码上下文、具备代码生成和补全能力的 LLM（如 Gemini Code Generation API）。
*   **API 集成**：通过 API 调用 LLM，将用户需求、Schema 信息和知识图谱上下文作为输入，接收生成的代码作为输出。
*   **本地模型 (可选)**：对于敏感代码或离线环境，未来可以考虑集成本地部署的开源代码生成模型。

## 3. 实施计划

1.  **阶段一：概念验证**：
    *   扩展 `create-linch-kit`，实现一个简单的 AI 调用，根据一个 Schema 生成一个基础的 CRUD 文件。
    *   验证 AI 生成代码的质量和可用性。
2.  **阶段二：Schema 驱动的自动化**：
    *   实现根据 Schema 自动生成完整的 CRUD 模块（包括服务、tRPC 路由、UI 组件）。
    *   确保生成的代码符合 LinchKit 的编码规范和架构模式。
3.  **阶段三：上下文感知生成**：
    *   集成 LinchKit 知识图谱 (Graph RAG) 的查询能力，使 AI 在生成代码时能够利用现有上下文。
    *   实现 AI 辅助的测试用例和文档生成。
4.  **阶段四：自然语言交互**：
    *   允许用户通过自然语言描述需求，AI 将其转化为可执行的代码生成指令。
    *   提供更智能的交互式问答，引导用户提供必要的信息。
5.  **阶段五：持续优化**：
    *   收集用户反馈，不断优化 AI 生成代码的质量和准确性。
    *   扩展代码生成范围，覆盖更多 LinchKit 模块和功能。
