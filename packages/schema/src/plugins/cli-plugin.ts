/**
 * Schema CLI Êèí‰ª∂
 *
 * Â∞Ü schema Áõ∏ÂÖ≥ÁöÑ CLI ÂëΩ‰ª§Ê≥®ÂÜåÂà∞ core ÂåÖÁöÑ CLI Á≥ªÁªü‰∏≠
 */

import type { CommandPlugin, CommandMetadata, CLIContext } from '@linch-kit/core'
import { writePrismaSchema } from '../generators/prisma'
import { writeValidators } from '../generators/validators'
import { writeMockFactories, generateTestDataFiles } from '../generators/mock'
import { writeOpenAPISpec } from '../generators/openapi'
import { getAllEntities, clearEntityRegistry } from '../core/entity'
import { loadConfig, type SchemaConfig } from '../config/loader'
import { pathToFileURL } from 'url'
import { resolve } from 'path'
import { glob } from 'glob'
import { existsSync, writeFileSync } from 'fs'

/**
 * ‰ªé linch.config.ts Âä†ËΩΩ schema ÈÖçÁΩÆ
 */
async function loadLinchConfig(): Promise<SchemaConfig> {
  try {
    // Â∞ùËØïÂä†ËΩΩ linch.config.ts ‰ΩøÁî® tsx
    const tsConfigPath = resolve(process.cwd(), 'linch.config.ts')
    if (existsSync(tsConfigPath)) {
      try {
        // ‰ΩøÁî® tsx Âä®ÊÄÅÂä†ËΩΩ TypeScript Êñá‰ª∂
        const { execSync } = await import('child_process')
        const configJson = execSync(
          `npx tsx -e "import config from '${tsConfigPath}'; console.log(JSON.stringify(config.schema || {}))"`,
          { encoding: 'utf8', cwd: process.cwd() }
        ).trim()

        const config = JSON.parse(configJson)
        return config
      } catch (tsxError) {
        console.warn('‚ö†Ô∏è Failed to load TypeScript config with tsx:', tsxError instanceof Error ? tsxError.message : String(tsxError))
      }
    }

    // Â∞ùËØïÂä†ËΩΩ linch.config.js (ÁºñËØëÂêéÁöÑÁâàÊú¨)
    const jsConfigPath = resolve(process.cwd(), 'linch.config.js')
    if (existsSync(jsConfigPath)) {
      const configModule = await import(pathToFileURL(jsConfigPath).href)
      const config = configModule.default || configModule
      return config.schema || {}
    }

    // Â∞ùËØïÂä†ËΩΩ linch.config.mjs
    const mjsConfigPath = resolve(process.cwd(), 'linch.config.mjs')
    if (existsSync(mjsConfigPath)) {
      const configModule = await import(pathToFileURL(mjsConfigPath).href)
      const config = configModule.default || configModule
      return config.schema || {}
    }

    // ÊúÄÂêéÂõûÈÄÄÂà∞ÂéüÊúâÁöÑ schema ÈÖçÁΩÆÂä†ËΩΩ
    return await loadConfig()
  } catch (error) {
    console.warn('‚ö†Ô∏è Failed to load linch config, using default schema config')
    return await loadConfig()
  }
}

/**
 * Âä®ÊÄÅÂä†ËΩΩÁî®Êà∑ÁöÑÂÆû‰ΩìÊñá‰ª∂
 */
async function loadEntities(config: SchemaConfig, entitiesPath?: string) {
  // Ê∏ÖÁ©∫Áé∞ÊúâÁöÑÂÆû‰ΩìÊ≥®ÂÜå
  clearEntityRegistry()

  if (entitiesPath) {
    // Áî®Êà∑ÊåáÂÆö‰∫ÜÂÆû‰ΩìÊñá‰ª∂Ë∑ØÂæÑ
    const resolvedPath = resolve(process.cwd(), entitiesPath)
    if (existsSync(resolvedPath)) {
      await import(pathToFileURL(resolvedPath).href)
    } else {
      console.error(`‚ùå Entities file not found: ${resolvedPath}`)
      process.exit(1)
    }
  } else {
    // ‰ΩøÁî®ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑÊ®°Âºè
    const patterns = config.entities || []

    let found = false
    let allFiles: string[] = []

    for (const pattern of patterns) {
      try {
        const files = await glob(pattern, { cwd: process.cwd() })
        if (files.length > 0) {
          allFiles.push(...files)
          found = true
        }
      } catch (error) {
        // ÂøΩÁï•ÈîôËØØÔºåÁªßÁª≠Â∞ùËØï‰∏ã‰∏Ä‰∏™Ê®°Âºè
      }
    }

    if (!found) {
      console.error('‚ùå No entity files found. Please:')
      console.error('  1. Run `linch schema:init` to create a config file')
      console.error('  2. Or specify --entities-path')
      console.error('  3. Or place entity files in default locations:')
      patterns.forEach(pattern => console.error(`     - ${pattern}`))
      process.exit(1)
    }

    console.log(`üìÅ Found entity files: ${allFiles.join(', ')}`)
    for (const file of allFiles) {
      const filePath = resolve(process.cwd(), file)
      await import(pathToFileURL(filePath).href)
    }
  }

  const entities = getAllEntities()
  if (entities.length === 0) {
    console.error('‚ùå No entities registered. Make sure your entity files call defineEntity().')
    process.exit(1)
  }

  console.log(`‚úÖ Loaded ${entities.length} entities: ${entities.map(e => e.name).join(', ')}`)
}

/**
 * Schema CLI Êèí‰ª∂
 */
export const schemaCliPlugin: CommandPlugin = {
  name: '@linch-kit/schema',
  description: 'Schema generation and management commands',
  version: '0.2.1',
  aiTags: ['schema', 'generation', 'database', 'validation'],

  async register(registry: any): Promise<void> {
    const commands: Record<string, CommandMetadata> = {
      'schema:init': {
        description: 'Initialize schema configuration',
        options: [
          {
            flags: '-f, --force',
            description: 'Overwrite existing config file'
          }
        ],
        async handler(context: CLIContext): Promise<void> {
          console.log('‚úÖ Schema configuration is now part of linch.config.ts')
          console.log('üìù Edit linch.config.ts to customize your schema setup')
        }
      },

      'schema:generate:prisma': {
        description: 'Generate Prisma schema from entity definitions',
        options: [
          {
            flags: '-o, --output <path>',
            description: 'Output file path (overrides config)'
          },
          {
            flags: '-p, --provider <provider>',
            description: 'Database provider (overrides config)'
          },
          {
            flags: '--url <url>',
            description: 'Database URL (overrides config)'
          },
          {
            flags: '-e, --entities-path <path>',
            description: 'Path to entities file or directory'
          },
          {
            flags: '-c, --config <path>',
            description: 'Path to config file'
          }
        ],
        async handler(context: CLIContext): Promise<void> {
          const { args = [] } = context
          const options = args[args.length - 1] || {}

          try {
            console.log('üîÑ Loading configuration...')
            const config = await loadLinchConfig()

            console.log('üîÑ Loading entities...')
            await loadEntities(config, options.entitiesPath)

            const outputPath = options.output || config.output?.prisma || './prisma/schema.prisma'
            const provider = options.provider || config.database?.provider || 'postgresql'
            const databaseUrl = options.url || config.database?.url

            console.log('üîÑ Generating Prisma schema...')
            await writePrismaSchema(outputPath, {
              provider,
              databaseUrl,
            })
            console.log(`‚úÖ Prisma schema generated at: ${outputPath}`)
          } catch (error) {
            console.error('‚ùå Error generating Prisma schema:', error)
            process.exit(1)
          }
        }
      },

      'schema:generate:validators': {
        description: 'Generate Zod validators from entity definitions',
        options: [
          {
            flags: '-o, --output <path>',
            description: 'Output file path',
            defaultValue: './src/validators/generated.ts'
          },
          {
            flags: '-e, --entities-path <path>',
            description: 'Path to entities file or directory'
          }
        ],
        async handler(context: CLIContext): Promise<void> {
          const { args = [] } = context
          const options = args[args.length - 1] || {}

          try {
            console.log('üîÑ Loading configuration...')
            const config = await loadLinchConfig()

            console.log('üîÑ Loading entities...')
            await loadEntities(config, options.entitiesPath)

            console.log('üîÑ Generating validators...')
            await writeValidators(options.output)
            console.log('‚úÖ Validators generated successfully!')
          } catch (error) {
            console.error('‚ùå Error generating validators:', error)
            process.exit(1)
          }
        }
      },

      'schema:list': {
        description: 'List all registered entities',
        async handler(): Promise<void> {
          try {
            console.log('üîÑ Loading configuration...')
            const config = await loadLinchConfig()

            console.log('üîÑ Loading entities...')
            await loadEntities(config)

            const entities = getAllEntities()
            console.log('üìã Registered entities:')
            entities.forEach(entity => {
              console.log(`  - ${entity.name}`)
            })
            console.log(`\nTotal: ${entities.length} entities`)
          } catch (error) {
            console.error('‚ùå Error listing entities:', error)
            process.exit(1)
          }
        }
      },

      'schema:show': {
        description: 'Show entity details',
        arguments: [
          {
            name: 'entityName',
            description: 'Name of the entity to show',
            required: true
          }
        ],
        async handler(context: CLIContext): Promise<void> {
          const { args = [] } = context
          const entityName = args[0]

          if (!entityName) {
            console.error('‚ùå Entity name is required')
            process.exit(1)
          }

          try {
            console.log('üîÑ Loading configuration...')
            const config = await loadLinchConfig()

            console.log('üîÑ Loading entities...')
            await loadEntities(config)

            const entities = getAllEntities()
            const entity = entities.find(e => e.name === entityName)

            if (!entity) {
              console.error(`‚ùå Entity '${entityName}' not found`)
              process.exit(1)
            }

            console.log(`üìÑ Entity: ${entity.name}`)
            console.log(`Table: ${entity.meta?.model?.tableName || entity.name.toLowerCase()}`)

            if (entity.meta?.fields) {
              console.log('\nFields:')
              Object.entries(entity.meta.fields).forEach(([name, meta]) => {
                const attributes = []
                if (meta.id) attributes.push('PRIMARY KEY')
                if (meta.unique) attributes.push('UNIQUE')
                if (meta.createdAt) attributes.push('CREATED_AT')
                if (meta.updatedAt) attributes.push('UPDATED_AT')

                console.log(`  - ${name} ${attributes.length ? `(${attributes.join(', ')})` : ''}`)
              })
            }
          } catch (error) {
            console.error('‚ùå Error showing entity:', error)
            process.exit(1)
          }
        }
      }
    }

    // Ê≥®ÂÜåÊâÄÊúâÂëΩ‰ª§
    for (const [name, command] of Object.entries(commands)) {
      registry.registerCommand(name, command)
    }
  }
}

/**
 * Ê≥®ÂÜå Schema CLI Êèí‰ª∂
 */
export function registerSchemaCliPlugin() {
  // Ëøô‰∏™ÂáΩÊï∞‰ºöÂú®ÂåÖË¢´ÂØºÂÖ•Êó∂Ëá™Âä®Ë∞ÉÁî®
  // ÈÄöËøá core ÂåÖÁöÑÊèí‰ª∂Á≥ªÁªüÊ≥®ÂÜåÂëΩ‰ª§
  if (typeof globalThis !== 'undefined' && (globalThis as any).__LINCH_CLI_REGISTRY__) {
    (globalThis as any).__LINCH_CLI_REGISTRY__.registerPlugin(schemaCliPlugin)
  }
}
