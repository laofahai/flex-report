/**
 * @linch-kit/schema 代码生成器基础框架
 */

import type {
  Entity,
  GeneratedFile,
  Generator,
  CodeGeneratorOptions,
  GeneratorContext,
  GeneratorHooks,
} from '../types'

/**
 * 抽象代码生成器基类
 */
export abstract class BaseGenerator implements Generator {
  abstract readonly name: string

  /**
   * 生成代码
   */
  abstract generate(context: GeneratorContext): Promise<GeneratedFile[]>

  /**
   * 获取输出文件扩展名
   */
  protected abstract getFileExtension(): string

  /**
   * 生成文件头部注释
   */
  protected generateHeader(): string {
    return `/**
 * Generated by @linch-kit/schema
 * Do not edit this file manually
 * Generated at: ${new Date().toISOString()}
 */

`
  }

  /**
   * 格式化文件内容
   */
  protected formatContent(content: string): string {
    // 基础格式化逻辑
    return content.trim() + '\n'
  }

  /**
   * 创建生成文件对象
   */
  protected createGeneratedFile(
    path: string,
    content: string,
    type: GeneratedFile['type']
  ): GeneratedFile {
    return {
      path,
      content: this.generateHeader() + this.formatContent(content),
      type,
    }
  }

  /**
   * 验证实体定义
   */
  protected validateEntities(entities: Entity[]): void {
    if (!entities || entities.length === 0) {
      throw new Error('No entities provided for code generation')
    }

    entities.forEach(entity => {
      if (!entity.name) {
        throw new Error('Entity name is required')
      }
      if (!entity.fields || Object.keys(entity.fields).length === 0) {
        throw new Error(`Entity ${entity.name} has no fields defined`)
      }
    })
  }

  /**
   * 转换为snake_case
   */
  protected toSnakeCase(str: string): string {
    return str
      .replace(/([A-Z])/g, '_$1')
      .toLowerCase()
      .replace(/^_/, '')
  }

  /**
   * 转换为camelCase
   */
  protected toCamelCase(str: string): string {
    return str
      .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())
      .replace(/^[A-Z]/, letter => letter.toLowerCase())
  }

  /**
   * 转换为PascalCase
   */
  protected toPascalCase(str: string): string {
    return str
      .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())
      .replace(/^[a-z]/, letter => letter.toUpperCase())
  }

  /**
   * 转换为kebab-case
   */
  protected toKebabCase(str: string): string {
    return str
      .replace(/([A-Z])/g, '-$1')
      .toLowerCase()
      .replace(/^-/, '')
  }
}

/**
 * 代码生成器管理器
 */
export class CodeGenerator {
  private generators: Map<string, Generator> = new Map()
  private options: CodeGeneratorOptions
  private hooks: GeneratorHooks

  constructor(options: CodeGeneratorOptions) {
    this.options = options
    this.hooks = options.hooks || {}

    this.validateOptions()
  }

  /**
   * 注册生成器
   */
  registerGenerator(generator: Generator): this {
    this.generators.set(generator.name, generator)
    return this
  }

  /**
   * 注册多个生成器
   */
  registerGenerators(generators: Generator[]): this {
    generators.forEach(generator => this.registerGenerator(generator))
    return this
  }

  /**
   * 获取生成器
   */
  getGenerator(name: string): Generator | undefined {
    return this.generators.get(name)
  }

  /**
   * 获取所有生成器
   */
  getAllGenerators(): Generator[] {
    return Array.from(this.generators.values())
  }

  /**
   * 生成所有代码
   */
  async generate(): Promise<GeneratedFile[]> {
    const context: GeneratorContext = {
      entities: this.options.entities,
      outputDir: this.options.outputDir || './generated',
      config: this.options.config || {},
      schema: {
        name: 'default',
        version: '1.0.0',
        entities: this.options.entities,
        config: this.options.config || {},
      },
      options: this.options,
    }

    // 执行生成前钩子
    if (this.hooks.beforeGenerate) {
      await this.hooks.beforeGenerate(context)
    }

    const allFiles: GeneratedFile[] = []

    // 执行所有生成器
    for (const generator of this.generators.values()) {
      try {
        const files = await generator.generate(context)

        // 执行文件生成后钩子
        for (const file of files) {
          if (this.hooks.afterFileGenerated) {
            await this.hooks.afterFileGenerated(file)
          }
          allFiles.push(file)
        }
      } catch (error) {
        throw new Error(
          `Generator ${generator.name} failed: ${error instanceof Error ? error.message : String(error)}`
        )
      }
    }

    // 执行生成完成钩子
    if (this.hooks.afterGenerate) {
      await this.hooks.afterGenerate(allFiles, context)
    }

    return allFiles
  }

  /**
   * 生成特定类型的代码
   */
  async generateByType(type: string): Promise<GeneratedFile[]> {
    const generator = this.generators.get(type)
    if (!generator) {
      throw new Error(`Generator ${type} not found`)
    }

    const context: GeneratorContext = {
      entities: this.options.entities,
      outputDir: this.options.outputDir || './generated',
      config: this.options.config || {},
      schema: {
        name: 'default',
        version: '1.0.0',
        entities: this.options.entities,
        config: this.options.config || {},
      },
      options: this.options,
    }
    return generator.generate(context)
  }

  /**
   * 生成到文件系统
   */
  async generateToFiles(): Promise<void> {
    const files = await this.generate()

    if (!this.options.outputDir) {
      throw new Error('Output directory not specified')
    }

    // 这里应该写入文件系统，暂时只返回文件列表
    console.log(`Generated ${files.length} files:`)
    files.forEach(file => {
      console.log(`  - ${file.path} (${file.type})`)
    })
  }

  /**
   * 验证选项
   */
  private validateOptions(): void {
    if (!this.options.entities || this.options.entities.length === 0) {
      throw new Error('No entities provided for code generation')
    }
  }
}

/**
 * 创建代码生成器
 *
 * @example
 * ```typescript
 * const generator = createGenerator({
 *   entities: [User, Post, Comment],
 *   outputDir: './generated'
 * })
 *
 * generator
 *   .registerGenerator(new TypeScriptGenerator())
 *   .registerGenerator(new PrismaGenerator())
 *   .registerGenerator(new ZodGenerator())
 *
 * await generator.generate()
 * ```
 */
export function createGenerator(options: CodeGeneratorOptions): CodeGenerator {
  return new CodeGenerator(options)
}

/**
 * 生成器注册表
 */
export class GeneratorRegistry {
  private static generators: Map<string, new () => Generator> = new Map()

  /**
   * 注册生成器类
   */
  static register(name: string, generatorClass: new () => Generator): void {
    this.generators.set(name, generatorClass)
  }

  /**
   * 创建生成器实例
   */
  static create(name: string): Generator {
    const GeneratorClass = this.generators.get(name)
    if (!GeneratorClass) {
      throw new Error(`Generator ${name} not registered`)
    }
    return new GeneratorClass()
  }

  /**
   * 获取所有注册的生成器名称
   */
  static getRegisteredNames(): string[] {
    return Array.from(this.generators.keys())
  }

  /**
   * 创建所有注册的生成器
   */
  static createAll(): Generator[] {
    return Array.from(this.generators.values()).map(GeneratorClass => new GeneratorClass())
  }
}

/**
 * 快速创建并运行代码生成器
 *
 * @example
 * ```typescript
 * await quickGenerate({
 *   entities: [User, Post],
 *   generators: ['typescript', 'prisma', 'zod'],
 *   outputDir: './generated'
 * })
 * ```
 */
export async function quickGenerate(options: {
  entities: Entity[]
  generators: string[]
  outputDir?: string
  hooks?: GeneratorHooks
}): Promise<GeneratedFile[]> {
  const generator = createGenerator({
    entities: options.entities,
    outputDir: options.outputDir,
    hooks: options.hooks,
  })

  // 注册指定的生成器
  options.generators.forEach(name => {
    const gen = GeneratorRegistry.create(name)
    generator.registerGenerator(gen)
  })

  return generator.generate()
}
